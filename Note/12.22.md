

### 什么是EDR?

[https://juejin.cn/post/6844903992078630925](https://juejin.cn/post/6844903992078630925)



### 应用 Valgrind 发现 Linux 程序的内存问题

[https://www.ibm.com/developerworks/cn/linux/l-cn-valgrind/index.html](https://www.ibm.com/developerworks/cn/linux/l-cn-valgrind/index.html)

![典型内存空间布局](https://i.loli.net/2020/12/22/7fLHSUwpeZagF4o.jpg)

<center>典型内存空间布局</center>

一个典型的Linux C程序内存空间由如下几部分组成：

- **代码段（.text）。**这里存放的是CPU要执行的指令。代码段是可共享的，相同的代码在内存中只会有一个拷贝，同时这个段是只读的，防止程序由于错误而修改自身的指令。
- **初始化数据段（.data）。**这里存放的是程序中需要明确赋初始值的变量，例如位于所有函数之外的全局变量：int val=100。需要强调的是，以上两段都是位于程序的可执行文件中，内核在调用exec函数启动该程序时从源程序文件中读入。
- **未初始化数据段（.bss）**。位于这一段中的数据，内核在执行该程序前，将其初始化为0或者null。例如出现在任何函数之外的全局变量：int sum;
- **堆（Heap）。**这个段用于在程序中进行动态内存申请，例如经常用到的malloc，new系列函数就是从这个段中申请内存。
- **栈（Stack）。**函数中的局部变量以及在函数调用过程中产生的临时变量都保存在此段中。



参考：

1. [内存调试技巧](https://www.ibm.com/developerworks/cn/aix/library/au-memorytechniques.html)
2. [如何在linux下检测内存泄漏](https://www.ibm.com/developerworks/cn/linux/l-mleak/)





### Perl简介

1987年[Larry Wall](https://baike.baidu.com/item/Larry Wall)发布Perl1.0以来，用户数一直急剧增加，同时越来越多的程序员与软件开发者(商)参与Perl的开发。从最初被当做一种跨平台环境中书写可移植工具的高级语言开始，Perl被广泛地认为是一种工业级的强大工具，可以在任何地方用来完成你的工作。perl的前身是Unix系统管理的一个工具，被用在无数的小任务里。后逐渐发展成为一种功能强大的程序设计语言，用作Web编程、数据库处理、XML处理以及系统管理；在完成这些工作时，同时仍能处理日常细小工作，这是它的设计初衷。Perl特别适合系统管理和Web编程。实际上已经被用在所有Unix(包括Linux)捆绑在一起作为标准部件发布，同时也用于Microsoft Windows和几乎所有操作系统。Perl的应用非常广泛。







### 什么是LLVM？

[https://www.jianshu.com/p/1367dad95445](https://www.jianshu.com/p/1367dad95445)





### 动态二进制插桩

---

参考：

1. [动态二进制插桩的原理和基本实现过程(Pin/DynamoRIO/Frida)](https://blog.csdn.net/woswod/article/details/89556676)
2. [Intel PinTools 安装使用教程](https://blog.csdn.net/maokelong95/article/details/78974271)
3. [动态插桩工具——Intel Pin的学习与使用（一）](https://zhuanlan.zhihu.com/p/248815246)
4. https://blog.csdn.net/maokelong95/article/details/78974271
5. [intel PIN](https://blog.csdn.net/u013129143/article/details/88874747)
6. [Pintool 官方手册解读](https://blog.csdn.net/sleeploke/article/details/105873165)
7. https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/5.2.1_pin.html
8. http://shell-storm.org/blog/A-binary-analysis-count-me-if-you-can/

---





动态二进制插桩（dynamic binary instrumentation ,DBI）技术是一种通过注入插桩代码，来分析二进制应用程序在运行时的行为的方法。

动态二进制插桩技术，可以在不影响程序动态执行结果的前提下，按照用户的分析需求，在程序执行过程中插入特定分析代码，实现对程序动态执行过程的监控与分析。目前，应用广泛的动态二进制分析平台有Pin，DynamoRIO和Frida等。

目前总共有两种类型的程序分析：静态程序分析和动态程序分析。在不运行程序的情况下进行的分析就是静态分析，当我们运行程序时所进行的分析就是动态分析。

静态分析的主要优点是它可以确保100％的代码覆盖率，通过动态分析，为了确保代码覆盖率更高，我需要多次运行程序，并使用不同的输入，以便分析采用不同的代码路径。但是，在某些情况下，由于软件应用程序太大，执行静态分析的成本太高。

正如我之前提到的，动态二进制插桩框架会直接在二进制文件或可执行文件中运行，这样我们就不需要程序的源代码，也不需要重新编译或重新链接程序，这个优势就允许我们分析许多软件。

动态二进制插桩框架被用于解决计算机体系结构问题，大量用于软件工程、程序分析和计算机安全。比如，软件工程师希望用它来深入了解他们开发的软件，系统的分析其性能和运行行为。动态二进制插桩框架的一个常见用途是模拟新的CPU指令。由于动态二进制系统在执行之前可以访问每条指令，因此硬件工程师实际上可以使用这些系统来测试当前不受硬件支持的新指令。他们可以模拟新的指令行为，而不是执行特定的指令。同样，他们也可以使用相同的方法来替换错误指令，并正确模拟所需行为。无论如何，从计算机安全的角度来看，动态二进制插桩系统可用于流程分析、污点分析、模糊测试、代码覆盖、生成测试历程、逆向工程、调试、漏洞插桩，甚至是修补漏洞以及自动利用。



大多数动态二进制插桩框架都有三种执行模式：解释模式（ Interpretation mode）、探测模式（probe mode）和JIT模式（just-in-time mode）。JIT模式是最常见的实现方式，也是最常用的模式，即使动态二进制插桩系统支持多种执行模式。在JIT模式下，原始二进制文件或可执行文件实际上从未被修改或执行过。因为，此时二进制文件被视为数据，修改后的二进制文件副本将在新的内存区域中生成(但只针对二进制文件的执行部分，而不是整个二进制文件)，此时执行的就是这个修改后的文件副本。而在解释模式中，二进制文件也被视为数据，每条指令都被用作具有相应功能的替代指令的查找表(由用户实现) 。在探测模式中，二进制文件实际上是通过使用新指令来覆盖旧的指令，来达到修改目的的，不过这会导致运行开销增大，但在某些体系结构(如x86)中，该方式却很好用。

无论采用哪种执行模式，一旦我们通过动态二进制插桩框架控制了程序的执行，就能够将插桩添加到执行程序中。我们可以在代码块之前和之后插入想要的代码，甚至也可以完全替换它们。

你可以在下图中看到执行过程：

![img](https://i.loli.net/2020/12/22/vKUrdzD6huiPSYc.png)



其中还包含不同程度的运行权限级别：

1.指令级（Instruction level）；

2.基本块级（Basic block level）；

3.函数级（Function level）；

可以看出，运行权限级别的选择将决定你对程序执行所控制的程度。显然，这会对性能的分析产生直接影响。另外，请注意，在大多数情况下，对整个程序进行插桩是不切实际的。

Pin tool由int main(int argc, char * argv[])函数开始，由NMAKE编译选项编译成特定的动态链接库，如果要编译自己的动态链接库，在Nmakefile文件中把要编译的动态链接库名字加到COMMON_TOOLS=后面，使用…\nmake.bat TARGET=ia32 xxx.dll命令进行编译。

如果在程序中要使用符号，要调用PIN_InitSymbols();

初始化PIN_Init(argc, argv)

PIN tool分

指令级插桩（instruction instrumentatio），通过函数INS_AddInstrumentFunctio实现。

轨迹级插装（trace instrumentation），通过函数TRACE_AddInstrumentFunction实现。（貌似就是基本块插装）

镜像级插装（image instrumentation），使用IMG_AddInstrumentFunction函数，由于其依赖于符号信息去确定函数边界，因此必须在调用PIN_Init之前调用PIN_InitSymbols。

函数级的插装（routine instrumentation），使用RTN_AddInstrumentFunction函数。函数级插装比镜像级插装更有效，因为只有镜像中的一小部分函数被执行。

四种插装粒度。其中，IMG_AddInstrumentFunction和RTN_AddInstrumentFunction需要先调用PIN_InitSymbols()，来分析出符号。在无符号的程序中，IMG_AddInstrumentFunction和RTN_AddInstrumentFunction无法分析出相应的需要插装的块。
在各种粒度的插装函数调用时，可以添加自己的处理函数在代码中，程序被加载后，在被插装的代码运行时，自己添加的函数会被调用。

INS_AddInstrumentFunctio、TRACE_AddInstrumentFunction、IMG_AddInstrumentFunction、RTN_AddInstrumentFunction指定的回调函数只有在相应的代码被分析到时才会被调用，即分析到一次只被调用一次，但程序运行过程中一般不再被调用，但INS_InsertCall之类的程序添加的函数，是在相应的代码位置添加函数，根据程序运行的情况，会被多次调用。

在INS_AddInstrumentFunctio指令级插装的代码中，只有在INS_AddInstrumentFunctio指定的函数被调用时INS指令才有效，在INS_InsertCall函数中，INS无效。







> 四种插装粒度。其中，IMG_AddInstrumentFunction和RTN_AddInstrumentFunction需要先调用PIN_InitSymbols()，来分析出符号。在无符号的程序中，IMG_AddInstrumentFunction和RTN_AddInstrumentFunction无法分析出相应的需要插装的块。
> 在各种粒度的插装函数调用时，可以添加自己的处理函数在代码中，程序被加载后，在被插装的代码运行时，自己添加的函数会被调用。

#### 指令级插桩(instruction instrumentation)

---

通过函数`INS_AddInstrumentFunction`实现。

---

##### 计数

`The example can be found in source/tools/ManualExamples/inscount0.cpp`

```cpp
#include <iostream>
#include <fstream>
#include "pin.H"
using std::cerr;
using std::ofstream;
using std::ios;
using std::string;
using std::endl;

ofstream OutFile;

// 设置静态计数器
static UINT64 icount = 0;

// 当每一个指令执行的时候，这个函数被调用
VOID docount() { icount++; }


// 这里Instruction函数调用了INS_InsertCall函数，pin调用这个函数每当有一个新的指令到来的时候
VOID Instruction(INS ins, VOID *v)
{
    // Insert a call to docount before every instruction, no arguments are passed
    /*
    ins:需要插桩的指令
    IPOINT_BEFORE:需要插桩的位置(有IPOINT_BEFORE、IPOINT_AFTER、IPOINT_ANYWHERE、IPOINT_TAKEN_BRANCH四种类型)
    docount:需要插桩的函数的指针
    IARG_END:代表函数参数输入结束
    */
    INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_END);
}

// 输出的文件
KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool",
    "o", "inscount.out", "specify output file name");

// 程序结束调用的函数
VOID Fini(INT32 code, VOID *v)
{
    // Write to a file since cout and cerr maybe closed by the application
    OutFile.setf(ios::showbase);
    OutFile << "Count " << icount << endl;
    OutFile.close();
}

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */

INT32 Usage()
{
    cerr << "This tool counts the number of dynamic instructions executed" << endl;
    cerr << endl << KNOB_BASE::StringKnobSummary() << endl;
    return -1;
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */
/*   argc, argv are the entire command line: pin -t <toolname> -- ...    */
/* ===================================================================== */

int main(int argc, char * argv[])
{
    // pin初始化，对输入的参数进行解析
    if (PIN_Init(argc, argv)) return Usage();

    // open输出文件，一旦没有通过-o指定输出文件，就会以KnobOuputFile中的inscount.out作为默认输出文件。
    OutFile.open(KnobOutputFile.Value().c_str());

    // 设置插桩函数，这个函数是instruction级别插桩分析的核心函数之一
    // 它的作用是指定用于在instruction粒度插桩的函数，使得在每次执行一条instruction时执行所指定的函数，也就是第一个参数指向的函数。
    INS_AddInstrumentFunction(Instruction, 0);

    // 指定结束时执行的函数
    PIN_AddFiniFunction(Fini, 0);
    
    // 执行目标程序,不返回
    PIN_StartProgram();
    
    return 0;
}
```



##### 指令地址跟踪

在前面的示例中，我们没有向分析过程docount传递任何参数。在这个例子中，我们展示了如何传递参数。调用分析过程时，Pin允许您传递指令指针、寄存器的当前值、内存操作的有效地址、常量等。有关完整列表，请参阅 [IARG_TYPE](https://software.intel.com/sites/landingpage/pintool/docs/97438/Pin/html/group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d).

`The example can be found in source/tools/ManualExamples/itrace.cpp`

```cpp
#include <stdio.h>
#include "pin.H"

FILE * trace;

// This function is called before every instruction is executed
// and prints the IP
VOID printip(VOID *ip) { fprintf(trace, "%p\n", ip); }

// Pin calls this function every time a new instruction is encountered
VOID Instruction(INS ins, VOID *v)
{
    // Insert a call to printip before every instruction, and pass it the IP
    INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)printip, IARG_INST_PTR, IARG_END);
}

// This function is called when the application exits
VOID Fini(INT32 code, VOID *v)
{
    fprintf(trace, "#eof\n");
    fclose(trace);
}

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */

INT32 Usage()
{
    PIN_ERROR("This Pintool prints the IPs of every instruction executed\n" 
              + KNOB_BASE::StringKnobSummary() + "\n");
    return -1;
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int main(int argc, char * argv[])
{
    trace = fopen("itrace.out", "w");
    
    // Initialize pin
    if (PIN_Init(argc, argv)) return Usage();

    // Register Instruction to be called to instrument instructions
    INS_AddInstrumentFunction(Instruction, 0);

    // Register Fini to be called when the application exits
    PIN_AddFiniFunction(Fini, 0);
    
    // Start the program, never returns
    PIN_StartProgram();
    
    return 0;
}
```

##### 内存引用跟踪

上一个示例插入所有指令。有时，工具可能只想插入一类指令，如内存操作或分支指令。工具可以通过使用Pin API来实现这一点，该API包含对指令进行分类和检查的函数。基本API对所有指令集都是通用的，这里对其进行了描述。此外，还有一个针对[IA-32 ISA.](https://software.intel.com/sites/landingpage/pintool/docs/97438/Pin/html/group__INS__BASIC__API__IA32.html)的指令集。

在本例中，我们将通过检查指令来演示如何进行更多选择性的插装。此工具生成程序引用的所有内存地址的跟踪。这对于调试和模拟处理器中的数据缓存也很有用。

`The example can be found in source/tools/ManualExamples/pinatrace.cpp`

```cpp
/*
 *  This file contains an ISA-portable PIN tool for tracing memory accesses.
 */

#include <stdio.h>
#include "pin.H"


FILE * trace;

// Print a memory read record
VOID RecordMemRead(VOID * ip, VOID * addr)
{
    fprintf(trace,"%p: R %p\n", ip, addr);
}

// Print a memory write record
VOID RecordMemWrite(VOID * ip, VOID * addr)
{
    fprintf(trace,"%p: W %p\n", ip, addr);
}

// Is called for every instruction and instruments reads and writes
VOID Instruction(INS ins, VOID *v)
{
    // Instruments memory accesses using a predicated call, i.e.
    // the instrumentation is called iff the instruction will actually be executed.
    //
    // On the IA-32 and Intel(R) 64 architectures conditional moves and REP 
    // prefixed instructions appear as predicated instructions in Pin.
    UINT32 memOperands = INS_MemoryOperandCount(ins);

    // Iterate over each memory operand of the instruction.
    for (UINT32 memOp = 0; memOp < memOperands; memOp++)
    {
        if (INS_MemoryOperandIsRead(ins, memOp))
        {
            INS_InsertPredicatedCall(
                ins, IPOINT_BEFORE, (AFUNPTR)RecordMemRead,
                IARG_INST_PTR,
                IARG_MEMORYOP_EA, memOp,
                IARG_END);
        }
        // Note that in some architectures a single memory operand can be 
        // both read and written (for instance incl (%eax) on IA-32)
        // In that case we instrument it once for read and once for write.
        if (INS_MemoryOperandIsWritten(ins, memOp))
        {
            INS_InsertPredicatedCall(
                ins, IPOINT_BEFORE, (AFUNPTR)RecordMemWrite,
                IARG_INST_PTR,
                IARG_MEMORYOP_EA, memOp,
                IARG_END);
        }
    }
}

VOID Fini(INT32 code, VOID *v)
{
    fprintf(trace, "#eof\n");
    fclose(trace);
}

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */
   
INT32 Usage()
{
    PIN_ERROR( "This Pintool prints a trace of memory addresses\n" 
              + KNOB_BASE::StringKnobSummary() + "\n");
    return -1;
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int main(int argc, char *argv[])
{
    if (PIN_Init(argc, argv)) return Usage();

    trace = fopen("pinatrace.out", "w");

    INS_AddInstrumentFunction(Instruction, 0);
    PIN_AddFiniFunction(Fini, 0);

    // Never returns
    PIN_StartProgram();
    
    return 0;
}
```



#### 镜像粒度插桩(image instrumentation)

---

使用`IMG_AddInstrumentFunction`函数，由于其依赖于符号信息去确定函数边界，因此必须在调用`PIN_Init`之前调用`PIN_InitSymbols`。

---

**IMG 表示整个被加载进内存的二进制可执行模块（如可执行文件、动态链接库等）类型的数据结构**。每次被插桩进程在执行过程中加载了镜像类型文件时，就会被当做 IMG 类型处理。注册插桩 IMG 粒度加载和卸载的函数原型：

```text
IMG_AddInstrumentFunction(IMAGECALLBACK fun, VOID *v)
IMG_AddUnloadFunction(IMAGECALLBACK fun, VOID *v)
```

##### 检测镜像的加载和未卸载

下面的示例在每次加载或卸载图像时将消息打印到跟踪文件中。它实际上滥用了图像检测模式，因为Pintool既不检查图像，也不添加检测代码。

`The example can be found in source/tools/ManualExamples/imageload.cpp`

```cpp
//
// This tool prints a trace of image load and unload events
//

#include "pin.H"
#include <iostream>
#include <fstream>
#include <stdlib.h>

using namespace std;

KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool",
    "o", "imageload.out", "specify file name");

ofstream TraceFile;

// Pin calls this function every time a new img is loaded
// It can instrument the image, but this example does not
// Note that imgs (including shared libraries) are loaded lazily

VOID ImageLoad(IMG img, VOID *v)
{
    TraceFile << "Loading " << IMG_Name(img) << ", Image id = " << IMG_Id(img) << endl;
}

// Pin calls this function every time a new img is unloaded
// You can't instrument an image that is about to be unloaded
VOID ImageUnload(IMG img, VOID *v)
{
    TraceFile << "Unloading " << IMG_Name(img) << endl;
}

// This function is called when the application exits
// It closes the output file.
VOID Fini(INT32 code, VOID *v)
{
    if (TraceFile.is_open()) { TraceFile.close(); }
}

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */

INT32 Usage()
{
    PIN_ERROR("This tool prints a log of image load and unload events\n"
             + KNOB_BASE::StringKnobSummary() + "\n");
    return -1;
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int main(int argc, char * argv[])
{
    // Initialize symbol processing
    PIN_InitSymbols();
    
    // Initialize pin
    if (PIN_Init(argc, argv)) return Usage();
    
    TraceFile.open(KnobOutputFile.Value().c_str());
    
    // Register ImageLoad to be called when an image is loaded
    IMG_AddInstrumentFunction(ImageLoad, 0);

    // Register ImageUnload to be called when an image is unloaded
    IMG_AddUnloadFunction(ImageUnload, 0);

    // Register Fini to be called when the application exits
    PIN_AddFiniFunction(Fini, 0);
    
    // Start the program, never returns
    PIN_StartProgram();
    
    return 0;
}
```



#### 轨迹粒度插桩(trace instrumentation)

---

通过函数`TRACE_AddInstrumentFunction`实现。

---

(貌似就是基本块插装)

TRACE 表示一个单入口、多出口的指令序列的数据结构。Pin 将 TRACE 分为若干基本块 BBL（Basic Block），一个 BLL 是一个单入口、单出口的指令序列。TRACE 在指令发生跳转时进行插入，进一步进行基本块分析，常用于记录程序执行序列。注册 TRACE 粒度插桩函数原型为：

```text
TRACE_AddInstrumentFunction(TRACE_INSTRUMENT_CALLBACK fun, VOID *val)
```

##### 更高效的指令计数

在这个示例中，我们通过在检测时计算BBL中的指令数量，并在每个BBL中增加计数器一次，而不是在每个指令中增加一次，来提高效率

`The example can be found in source/tools/ManualExamples/inscount1.cpp`

```cpp
#include <iostream>
#include <fstream>
#include "pin.H"

ofstream OutFile;

// The running count of instructions is kept here
// make it static to help the compiler optimize docount
static UINT64 icount = 0;

// This function is called before every block
VOID docount(UINT32 c) { icount += c; }
    
// Pin calls this function every time a new basic block is encountered
// It inserts a call to docount
VOID Trace(TRACE trace, VOID *v)
{
    // Visit every basic block  in the trace
    for (BBL bbl = TRACE_BblHead(trace); BBL_Valid(bbl); bbl = BBL_Next(bbl))
    {
        // Insert a call to docount before every bbl, passing the number of instructions
        BBL_InsertCall(bbl, IPOINT_BEFORE, (AFUNPTR)docount, IARG_UINT32, BBL_NumIns(bbl), IARG_END);
    }
}

KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool",
    "o", "inscount.out", "specify output file name");

// This function is called when the application exits
VOID Fini(INT32 code, VOID *v)
{
    // Write to a file since cout and cerr maybe closed by the application
    OutFile.setf(ios::showbase);
    OutFile << "Count " << icount << endl;
    OutFile.close();
}

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */

INT32 Usage()
{
    cerr << "This tool counts the number of dynamic instructions executed" << endl;
    cerr << endl << KNOB_BASE::StringKnobSummary() << endl;
    return -1;
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int main(int argc, char * argv[])
{
    // Initialize pin
    if (PIN_Init(argc, argv)) return Usage();

    OutFile.open(KnobOutputFile.Value().c_str());

    // Register Instruction to be called to instrument instructions
    TRACE_AddInstrumentFunction(Trace, 0);

    // Register Fini to be called when the application exits
    PIN_AddFiniFunction(Fini, 0);
    
    // Start the program, never returns
    PIN_StartProgram();
    
    return 0;
}
```



#### 函数粒度插桩(routine instrumentation)

---

使用`RTN_AddInstrumentFunction`函数。函数级插装比镜像级插装更有效，因为只有镜像中的一小部分函数被执行。

---

什么是BBL？

可以理解成一个分分支块

##### 程序指令计数

下面的例子使用一个程序来计算一个过程被调用的次数，以及每个过程中执行的指令的总数。当它完成时，它打印一个配置文件到proccount.out

`The example can be found in source/tools/ManualExamples/proccount.cpp`

```cpp
//
// This tool counts the number of times a routine is executed and 
// the number of instructions executed in a routine
//

#include <fstream>
#include <iomanip>
#include <iostream>
#include <string.h>
#include "pin.H"

ofstream outFile;

// Holds instruction count for a single procedure
typedef struct RtnCount
{
    string _name;
    string _image;
    ADDRINT _address;
    RTN _rtn;
    UINT64 _rtnCount;
    UINT64 _icount;
    struct RtnCount * _next;
} RTN_COUNT;

// Linked list of instruction counts for each routine
RTN_COUNT * RtnList = 0;

// This function is called before every instruction is executed
VOID docount(UINT64 * counter)
{
    (*counter)++;
}
    
const char * StripPath(const char * path)
{
    const char * file = strrchr(path,'/');
    if (file)
        return file+1;
    else
        return path;
}

// Pin calls this function every time a new rtn is executed
VOID Routine(RTN rtn, VOID *v)
{
    
    // Allocate a counter for this routine
    RTN_COUNT * rc = new RTN_COUNT;

    // The RTN goes away when the image is unloaded, so save it now
    // because we need it in the fini
    rc->_name = RTN_Name(rtn);
    rc->_image = StripPath(IMG_Name(SEC_Img(RTN_Sec(rtn))).c_str());
    rc->_address = RTN_Address(rtn);
    rc->_icount = 0;
    rc->_rtnCount = 0;

    // Add to list of routines
    rc->_next = RtnList;
    RtnList = rc;
            
    RTN_Open(rtn);
            
    // Insert a call at the entry point of a routine to increment the call count
    RTN_InsertCall(rtn, IPOINT_BEFORE, (AFUNPTR)docount, IARG_PTR, &(rc->_rtnCount), IARG_END);
    
    // For each instruction of the routine
    for (INS ins = RTN_InsHead(rtn); INS_Valid(ins); ins = INS_Next(ins))
    {
        // Insert a call to docount to increment the instruction counter for this rtn
        INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_PTR, &(rc->_icount), IARG_END);
    }

    
    RTN_Close(rtn);
}

// This function is called when the application exits
// It prints the name and count for each procedure
VOID Fini(INT32 code, VOID *v)
{
    outFile << setw(23) << "Procedure" << " "
          << setw(15) << "Image" << " "
          << setw(18) << "Address" << " "
          << setw(12) << "Calls" << " "
          << setw(12) << "Instructions" << endl;

    for (RTN_COUNT * rc = RtnList; rc; rc = rc->_next)
    {
        if (rc->_icount > 0)
            outFile << setw(23) << rc->_name << " "
                  << setw(15) << rc->_image << " "
                  << setw(18) << hex << rc->_address << dec <<" "
                  << setw(12) << rc->_rtnCount << " "
                  << setw(12) << rc->_icount << endl;
    }

}

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */

INT32 Usage()
{
    cerr << "This Pintool counts the number of times a routine is executed" << endl;
    cerr << "and the number of instructions executed in a routine" << endl;
    cerr << endl << KNOB_BASE::StringKnobSummary() << endl;
    return -1;
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int main(int argc, char * argv[])
{
    // Initialize symbol table code, needed for rtn instrumentation
    PIN_InitSymbols();

    outFile.open("proccount.out");

    // Initialize pin
    if (PIN_Init(argc, argv)) return Usage();

    // Register Routine to be called to instrument rtn
    RTN_AddInstrumentFunction(Routine, 0);

    // Register Fini to be called when the application exits
    PIN_AddFiniFunction(Fini, 0);
    
    // Start the program, never returns
    PIN_StartProgram();
    
    return 0;
}
```

![这里写图片描述](https://i.loli.net/2020/12/23/29oTwANDbaChqQv.png)



### 其他

#### 如何传递参数

假如我们需要插入的函数代码如下：

```
VOID printip(VOID *ip) { fprintf(trace, "%p\n", ip); }
```

插桩代码可以像下面这样将一个指针传递给插入的函数：

```
VOID Instruction(INS ins, VOID *v)
{
// param1:需要插入的指令
// param2:表示指令怎么插入(前后.)
// param3:需要插入的代码函数指针,
// param4:表示传什么参数到函数(IP) 
// param5:表示参数传递结束    
    INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)printip, IARG_INST_PTR, IARG_END);
}
```

由上面的代码可以知道，在第三个参数和最后一个结束符参数IARG_END之间可以插入多个参数。这里传递的是当前指令的地址。

![image-20201225105837115](https://i.loli.net/2020/12/25/twPA3E79aTkXWMB.png)

参考地址：[https://software.intel.com/sites/landingpage/pintool/docs/98189/Pin/html/group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d](https://software.intel.com/sites/landingpage/pintool/docs/98189/Pin/html/group__INST__ARGS.html#ga089c27ca15e9ff139dd3a3f8a6f8451d)

参考文件：`source/tools/ManualExamples/itrace.cpp`

#### 用PIN提供的API来筛选指令

例如：

```cpp
// pin 提供的API,统计有多少条内存操作指令
UINT32 memOperands = INS_MemoryOperandCount(ins);
```

![image-20201224173437018](https://i.loli.net/2020/12/25/42TxlKYLtQkUedA.png)

可以设置下面这样的插桩函数

```cpp
VOID Instruction(INS ins, VOID *v)
{
// pin 提供的API,统计有多少天内存操作指令
    UINT32 memOperands = INS_MemoryOperandCount(ins);
    for (UINT32 memOp = 0; memOp < memOperands; memOp++)
    {
      // pin提供的API指令,  通过ID来识别是第几条内存指令
        if (INS_MemoryOperandIsRead(ins, memOp))
        {
            INS_InsertPredicatedCall(
                ins, IPOINT_BEFORE, (AFUNPTR)RecordMemRead,
                IARG_INST_PTR,
                //表明传入内存有效地址,下个参数必须是memOp的ID
                IARG_MEMORYOP_EA, memOp,
                IARG_END);
        }
        if (INS_MemoryOperandIsWritten(ins, memOp))
        {
            INS_InsertPredicatedCall(
                ins, IPOINT_BEFORE, (AFUNPTR)RecordMemWrite,
                IARG_INST_PTR,
                IARG_MEMORYOP_EA, memOp,
                IARG_END);
        }
    }
}
```

参考文件：`source/tools/ManualExamples/pinatrace.cpp`



#### 内存数据的获取和写入

展示了使用PIN_SafeCopy()去模拟LOAD操作,删除原来的指令,使用这个API 可以让PIN tool 读写应用的制定内存单元

```cpp
#include <stdio.h>
#include "pin.H"
#include "pin_isa.H"
#include <iostream>
#include <fstream>

std::ofstream* out = 0;

//=======================================================
//  Analysis routines
//=======================================================

// Move from memory to register
ADDRINT DoLoad(REG reg, ADDRINT * addr)
{
    *out << "Emulate loading from addr " << addr << " to " << REG_StringShort(reg) << endl;
    ADDRINT value;
    //      (dest , src,size)
    PIN_SafeCopy(&value, addr, sizeof(ADDRINT));
    return value;
}

//=======================================================
// Instrumentation routines
//=======================================================

VOID EmulateLoad(INS ins, VOID* v)
{
    // Find the instructions that move a value from memory to a register
    if (INS_Opcode(ins) == XED_ICLASS_MOV &&
        INS_IsMemoryRead(ins) && 
        INS_OperandIsReg(ins, 0) &&
        INS_OperandIsMemory(ins, 1))
    {
        // op0 <- *op1
        //INS_OperandReg 返回指令设计的寄存器
        //IARG_RETURN_REGS  把函数返回的值写入寄存器,下个参数表明写到那个寄存器
        
        INS_InsertCall(ins,
                       IPOINT_BEFORE,
                       AFUNPTR(DoLoad),
                       IARG_UINT32,
                       REG(INS_OperandReg(ins, 0)),
                       IARG_MEMORYREAD_EA,
                       IARG_RETURN_REGS,
                       INS_OperandReg(ins, 0),
                       IARG_END);

        // Delete the instruction
        INS_Delete(ins);
    }
}

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */

INT32 Usage()
{
    cerr << "This tool demonstrates the use of SafeCopy" << endl;
    cerr << endl << KNOB_BASE::StringKnobSummary() << endl;
    return -1;
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int main(int argc, char * argv[])
{
    // Write to a file since cout and cerr maybe closed by the application
    out = new std::ofstream("safecopy.out");

    // Initialize pin & symbol manager
    if (PIN_Init(argc, argv)) return Usage();
    PIN_InitSymbols();

    // Register EmulateLoad to be called to instrument instructions
    INS_AddInstrumentFunction(EmulateLoad, 0);

    // Never returns
    PIN_StartProgram();   
    return 0;
}

```



#### 指令的顺序

Pin为工具提供了多种方法来控制分析调用的执行顺序。执行顺序主要取决于插入操作（IPOINT）和调用顺序（call_order）

`the example can be found in source/tools/ManualExamples/invocation.cpp.`

```cpp
#include "pin.H"
#include <iostream>
#include <fstream>
using namespace std;

KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool",
    "o", "invocation.out", "specify output file name");

ofstream OutFile;

/*
 * Analysis routines
 */
VOID Taken( const CONTEXT * ctxt)
{
    ADDRINT TakenIP = (ADDRINT)PIN_GetContextReg( ctxt, REG_INST_PTR );
    OutFile << "Taken: IP = " << hex << TakenIP << dec << endl;
}

VOID Before(CONTEXT * ctxt)
{
    ADDRINT BeforeIP = (ADDRINT)PIN_GetContextReg( ctxt, REG_INST_PTR);
    OutFile << "Before: IP = " << hex << BeforeIP << dec << endl;
}


VOID After(CONTEXT * ctxt)
{
    ADDRINT AfterIP = (ADDRINT)PIN_GetContextReg( ctxt, REG_INST_PTR);
    OutFile << "After: IP = " << hex << AfterIP << dec << endl;
}

    
/*
 * Instrumentation routines
 */
VOID ImageLoad(IMG img, VOID *v)
{
    for (SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec))
    {
        // RTN_InsertCall() and INS_InsertCall() are executed in order of
        // appearance.  In the code sequence below, the IPOINT_AFTER is
        // executed before the IPOINT_BEFORE.
        for (RTN rtn = SEC_RtnHead(sec); RTN_Valid(rtn); rtn = RTN_Next(rtn))
        {
            // Open the RTN.
            RTN_Open( rtn );
            
            // IPOINT_AFTER is implemented by instrumenting each return
            // instruction in a routine.  Pin tries to find all return
            // instructions, but success is not guaranteed.
            RTN_InsertCall( rtn, IPOINT_AFTER, (AFUNPTR)After,
                            IARG_CONTEXT, IARG_END);
            
            // Examine each instruction in the routine.
            for( INS ins = RTN_InsHead(rtn); INS_Valid(ins); ins = INS_Next(ins) )
            {
                if( INS_IsRet(ins) )
                {
                    // instrument each return instruction.
                    // IPOINT_TAKEN_BRANCH always occurs last.
                    INS_InsertCall( ins, IPOINT_BEFORE, (AFUNPTR)Before,
                                   IARG_CONTEXT, IARG_END);
                    INS_InsertCall( ins, IPOINT_TAKEN_BRANCH, (AFUNPTR)Taken,
                                   IARG_CONTEXT, IARG_END);
                }
            }
            // Close the RTN.
            RTN_Close( rtn );
        }
    }
}

VOID Fini(INT32 code, VOID *v)
{
    OutFile.close();
}

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */

INT32 Usage()
{
    cerr << "This is the invocation pintool" << endl;
    cerr << endl << KNOB_BASE::StringKnobSummary() << endl;
    return -1;
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int main(int argc, char * argv[])
{
    // Initialize pin & symbol manager
    if (PIN_Init(argc, argv)) return Usage();
    PIN_InitSymbols();

    // Register ImageLoad to be called to instrument instructions
    IMG_AddInstrumentFunction(ImageLoad, 0);
    PIN_AddFiniFunction(Fini, 0);

    // Write to a file since cout and cerr maybe closed by the application
    OutFile.open(KnobOutputFile.Value().c_str());
    OutFile.setf(ios::showbase);
    
    // Start the program, never returns
    PIN_StartProgram();
    
    return 0;
}
/* ===================================================================== */
```





#### 查找函数参数的值

通常需要知道传递给函数的参数的值或返回值。您可以使用Pin查找此信息。使用RTN_InsertCall（）函数，可以指定感兴趣的参数。
下面的示例打印malloc（）和free（）的输入参数，以及malloc（）的返回值。

`The example can be found in source/tools/ManualExamples/malloctrace.cpp.`

```cpp
#include "pin.H"
#include <iostream>
#include <fstream>

/* ===================================================================== */
/* Names of malloc and free */
/* ===================================================================== */
#if defined(TARGET_MAC)
#define MALLOC "_malloc"
#define FREE "_free"
#else
#define MALLOC "malloc"
#define FREE "free"
#endif

/* ===================================================================== */
/* Global Variables */
/* ===================================================================== */

std::ofstream TraceFile;

/* ===================================================================== */
/* Commandline Switches */
/* ===================================================================== */

KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool",
    "o", "malloctrace.out", "specify trace file name");

/* ===================================================================== */


/* ===================================================================== */
/* Analysis routines                                                     */
/* ===================================================================== */
 
VOID Arg1Before(CHAR * name, ADDRINT size)
{
    TraceFile << name << "(" << size << ")" << endl;
}

VOID MallocAfter(ADDRINT ret)
{
    TraceFile << "  returns " << ret << endl;
}


/* ===================================================================== */
/* Instrumentation routines                                              */
/* ===================================================================== */
   
VOID Image(IMG img, VOID *v)
{
    // Instrument the malloc() and free() functions.  Print the input argument
    // of each malloc() or free(), and the return value of malloc().
    //
    //  Find the malloc() function.
    RTN mallocRtn = RTN_FindByName(img, MALLOC);
    if (RTN_Valid(mallocRtn))
    {
        RTN_Open(mallocRtn);

        // Instrument malloc() to print the input argument value and the return value.
        RTN_InsertCall(mallocRtn, IPOINT_BEFORE, (AFUNPTR)Arg1Before,
                       IARG_ADDRINT, MALLOC,
                       IARG_FUNCARG_ENTRYPOINT_VALUE, 0,
                       IARG_END);
        RTN_InsertCall(mallocRtn, IPOINT_AFTER, (AFUNPTR)MallocAfter,
                       IARG_FUNCRET_EXITPOINT_VALUE, IARG_END);

        RTN_Close(mallocRtn);
    }

    // Find the free() function.
    RTN freeRtn = RTN_FindByName(img, FREE);
    if (RTN_Valid(freeRtn))
    {
        RTN_Open(freeRtn);
        // Instrument free() to print the input argument value.
        RTN_InsertCall(freeRtn, IPOINT_BEFORE, (AFUNPTR)Arg1Before,
                       IARG_ADDRINT, FREE,
                       IARG_FUNCARG_ENTRYPOINT_VALUE, 0,
                       IARG_END);
        RTN_Close(freeRtn);
    }
}

/* ===================================================================== */

VOID Fini(INT32 code, VOID *v)
{
    TraceFile.close();
}

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */
   
INT32 Usage()
{
    cerr << "This tool produces a trace of calls to malloc." << endl;
    cerr << endl << KNOB_BASE::StringKnobSummary() << endl;
    return -1;
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int main(int argc, char *argv[])
{
    // Initialize pin & symbol manager
    PIN_InitSymbols();
    if( PIN_Init(argc,argv) )
    {
        return Usage();
    }
    
    // Write to a file since cout and cerr maybe closed by the application
    TraceFile.open(KnobOutputFile.Value().c_str());
    TraceFile << hex;
    TraceFile.setf(ios::showbase);
    
    // Register Image to be called to instrument functions.
    IMG_AddInstrumentFunction(Image, 0);
    PIN_AddFiniFunction(Fini, 0);

    // Never returns
    PIN_StartProgram();
    
    return 0;
}

/* ===================================================================== */
/* eof */
/* ===================================================================== */
```

执行结果：





#### 插桩多线程应用

`The example can be found in source/tools/ManualExamples/malloc_mt.cpp`

```cpp
#include <stdio.h>
#include "pin.H"

KNOB<string> KnobOutputFile(KNOB_MODE_WRITEONCE, "pintool",
    "o", "malloc_mt.out", "specify output file name");

//==============================================================
//  Analysis Routines
//==============================================================
// Note:  threadid+1 is used as an argument to the PIN_GetLock()
//        routine as a debugging aid.  This is the value that
//        the lock is set to, so it must be non-zero.

// lock serializes access to the output file.
FILE * out;
PIN_LOCK pinLock;

// Note that opening a file in a callback is only supported on Linux systems.
// See buffer-win.cpp for how to work around this issue on Windows.
//
// This routine is executed every time a thread is created.
VOID ThreadStart(THREADID threadid, CONTEXT *ctxt, INT32 flags, VOID *v)
{
    PIN_GetLock(&pinLock, threadid+1);
    fprintf(out, "thread begin %d\n",threadid);
    fflush(out);
    PIN_ReleaseLock(&pinLock);
}

// This routine is executed every time a thread is destroyed.
VOID ThreadFini(THREADID threadid, const CONTEXT *ctxt, INT32 code, VOID *v)
{
    PIN_GetLock(&pinLock, threadid+1);
    fprintf(out, "thread end %d code %d\n",threadid, code);
    fflush(out);
    PIN_ReleaseLock(&pinLock);
}

// This routine is executed each time malloc is called.
VOID BeforeMalloc( int size, THREADID threadid )
{
    PIN_GetLock(&pinLock, threadid+1);
    fprintf(out, "thread %d entered malloc(%d)\n", threadid, size);
    fflush(out);
    PIN_ReleaseLock(&pinLock);
}


//====================================================================
// Instrumentation Routines
//====================================================================

// This routine is executed for each image.
VOID ImageLoad(IMG img, VOID *)
{
    RTN rtn = RTN_FindByName(img, "malloc");
    
    if ( RTN_Valid( rtn ))
    {
        RTN_Open(rtn);
        
        RTN_InsertCall(rtn, IPOINT_BEFORE, AFUNPTR(BeforeMalloc),
                       IARG_FUNCARG_ENTRYPOINT_VALUE, 0,
                       IARG_THREAD_ID, IARG_END);

        RTN_Close(rtn);
    }
}

// This routine is executed once at the end.
VOID Fini(INT32 code, VOID *v)
{
    fclose(out);
}

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */

INT32 Usage()
{
    PIN_ERROR("This Pintool prints a trace of malloc calls in the guest application\n"
              + KNOB_BASE::StringKnobSummary() + "\n");
    return -1;
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */

int main(INT32 argc, CHAR **argv)
{
    // Initialize the pin lock
    PIN_InitLock(&pinLock);
    
    // Initialize pin
    if (PIN_Init(argc, argv)) return Usage();
    PIN_InitSymbols();
    
    out = fopen(KnobOutputFile.Value().c_str(), "w");

    // Register ImageLoad to be called when each image is loaded.
    IMG_AddInstrumentFunction(ImageLoad, 0);

    // Register Analysis routines to be called when a thread begins/ends
    PIN_AddThreadStartFunction(ThreadStart, 0);
    PIN_AddThreadFiniFunction(ThreadFini, 0);

    // Register Fini to be called when the application exits
    PIN_AddFiniFunction(Fini, 0);
    
    // Never returns
    PIN_StartProgram();
    
    return 0;
}
```

#### 在探测模式下替换例程(替换malloc函数)

探针模式是一种在指定例程的开始处使用Pin插入探针的方法。探测是放置在指定例程开头的跳转指令。探测器将控制流重定向到替换功能。在插入探针之前，将重新定位指定例程的前几条指令。替换函数调用被替换的例程并不少见。Pin提供了重新定位的地址以便于实现这一点。请参阅下面的示例。



使用探测器时，必须使用`Pin_startProgramProbedded（）`API启动Pin。

```cpp
#include "pin.H"
#include <iostream>
using namespace std;

typedef VOID * ( *FP_MALLOC )( size_t );

// This is the replacement routine.
//
VOID * NewMalloc( FP_MALLOC orgFuncptr, UINT32 arg0, ADDRINT returnIp )
{
    // Normally one would do something more interesting with this data.
    //
    cout << "NewMalloc ("
         << hex << ADDRINT ( orgFuncptr ) << ", " 
         << dec << arg0 << ", " 
         << hex << returnIp << ")"
         << endl << flush;

    // Call the relocated entry point of the original (replaced) routine.
    //
    VOID * v = orgFuncptr( arg0 );

    return v;
}


// Pin calls this function every time a new img is loaded.
// It is best to do probe replacement when the image is loaded,
// because only one thread knows about the image at this time.
//
VOID ImageLoad( IMG img, VOID *v )
{
    // See if malloc() is present in the image.  If so, replace it.
    //
    RTN rtn = RTN_FindByName( img, "malloc" );
    
    if (RTN_Valid(rtn))
    {
        if (RTN_IsSafeForProbedReplacement(rtn))
        {
            cout << "Replacing malloc in " << IMG_Name(img) << endl;

            // Define a function prototype that describes the application routine
            // that will be replaced.
            //
            PROTO proto_malloc = PROTO_Allocate(PIN_PARG(void *), CALLINGSTD_DEFAULT,
                "malloc", PIN_PARG(int), PIN_PARG_END());

            // Replace the application routine with the replacement function.
            // Additional arguments have been added to the replacement routine.
            //
            RTN_ReplaceSignatureProbed(rtn, AFUNPTR(NewMalloc),
                IARG_PROTOTYPE, proto_malloc,
                IARG_ORIG_FUNCPTR,
                IARG_FUNCARG_ENTRYPOINT_VALUE, 0,
                IARG_RETURN_IP,
                IARG_END);

            // Free the function prototype.
            //
            PROTO_Free(proto_malloc);
        }
        else
        {
            cout << "Skip replacing malloc in " << IMG_Name(img) << " since it is not safe." << endl;
        }
    }
}

/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */

INT32 Usage()
{
    cerr << "This tool demonstrates how to replace an original" << endl;
    cerr << " function with a custom function defined in the tool " << endl;
    cerr << " using probes.  The replacement function has a different " << endl;
    cerr << " signature from that of the original replaced function." << endl;
    cerr << endl << KNOB_BASE::StringKnobSummary() << endl;
    return -1;
}

/* ===================================================================== */
/* Main: Initialize and start Pin in Probe mode.                         */
/* ===================================================================== */

int main( INT32 argc, CHAR *argv[] )
{
    // Initialize symbol processing
    //
    PIN_InitSymbols();
    
    // Initialize pin
    //
    if (PIN_Init(argc, argv)) return Usage();
    
    // Register ImageLoad to be called when an image is loaded
    //
    IMG_AddInstrumentFunction( ImageLoad, 0 );
    
    // Start the program in probe mode, never returns
    //
    PIN_StartProgramProbed();
    
    return 0;
}
```



参考文件：`source/tools/ManualExamples/replacesigprobed.cpp`



#### 插装子进程

the example can be found in `source/tools/ManualExamples/follow_child_tool.cpp`. To build this test, execute:

```cpp
$ make follow_child_tool.test
#include "pin.H"
#include <iostream>
#include <stdio.h>
#include <unistd.h>

/* ===================================================================== */
/* Command line Switches */
/* ===================================================================== */


BOOL FollowChild(CHILD_PROCESS childProcess, VOID * userData)
{
    fprintf(stdout, "before child:%u\n", getpid());
    return TRUE;
}        

/* ===================================================================== */

int main(INT32 argc, CHAR **argv)
{
    PIN_Init(argc, argv);

    PIN_AddFollowChildProcessFunction(FollowChild, 0);

    PIN_StartProgram();

    return 0;
}
```





#### 在Forks前后插桩

Pin允许Pintools注册fork周围的通知回调。 [PIN_AddForkFunction()](https://software.intel.com/sites/landingpage/pintool/docs/97438/Pin/html/group__PIN__CONTROL.html#ga7282900fb6160031936d8b63fecc4e21) 和PIN_AddForkFunctionProbed()回调允许您定义要在以下fpoint之一执行的函数：

```text
FPOINT_BEFORE            Call-back in parent, just before fork.
FPOINT_AFTER_IN_PARENT   Call-back in parent, immediately after fork.
FPOINT_AFTER_IN_CHILD    Call-back in child, immediately after fork.
```

The example can be found in `source/tools/ManualExamples/fork_jit_tool.cpp`. To build this test, execute:

```cpp
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

#include "pin.H"

#include <iostream>
#include <fstream>

using namespace std;


INT32 Usage()
{
    cerr <<
        "This pin tool registers callbacks around fork().\n"
        "\n";
    cerr << KNOB_BASE::StringKnobSummary();
    cerr << endl;
    return -1;
}


pid_t parent_pid;
PIN_LOCK pinLock;

VOID BeforeFork(THREADID threadid, const CONTEXT* ctxt, VOID * arg)
{
    PIN_GetLock(&pinLock, threadid+1);
    cerr << "TOOL: Before fork." << endl;
    PIN_ReleaseLock(&pinLock);
    parent_pid = PIN_GetPid();
}

VOID AfterForkInParent(THREADID threadid, const CONTEXT* ctxt, VOID * arg)
{
    PIN_GetLock(&pinLock, threadid+1);
    cerr << "TOOL: After fork in parent." << endl;
    PIN_ReleaseLock(&pinLock);

    if (PIN_GetPid() != parent_pid)
    {
        cerr << "PIN_GetPid() fails in parent process" << endl;
        exit(-1);
    }
}

VOID AfterForkInChild(THREADID threadid, const CONTEXT* ctxt, VOID * arg)
{
    PIN_GetLock(&pinLock, threadid+1);
    cerr << "TOOL: After fork in child." << endl;
    PIN_ReleaseLock(&pinLock);
    
    if ((PIN_GetPid() == parent_pid) || (getppid() != parent_pid))
    {
        cerr << "PIN_GetPid() fails in child process" << endl;
        exit(-1);
    }
}

int main(INT32 argc, CHAR **argv)
{
    PIN_InitSymbols();
    if( PIN_Init(argc,argv) )
    {
        return Usage();
    }
    
    // Initialize the pin lock
    PIN_InitLock(&pinLock);
    
    // Register a notification handler that is called when the application
    // forks a new process.
    PIN_AddForkFunction(FPOINT_BEFORE, BeforeFork, 0);  
    PIN_AddForkFunction(FPOINT_AFTER_IN_PARENT, AfterForkInParent, 0);
    PIN_AddForkFunction(FPOINT_AFTER_IN_CHILD, AfterForkInChild, 0);
    
    // Never returns
    PIN_StartProgram();
    
    return 0;
}
```



![image-20201224103220289](https://i.loli.net/2020/12/25/59GjgLhsFrpcROf.png)







#### 自定义 PinTool

